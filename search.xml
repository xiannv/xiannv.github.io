<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm模块装机]]></title>
    <url>%2F2019%2F02%2F14%2Fnpm%E6%A8%A1%E5%9D%97%E8%A3%85%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[在cmd中输入npm install回车后，能够帮我们装上相应的模块，这当中实现的过程是怎么样的呢？ 安装过程 执行工程自身的preinstall, 定义的 preinstall钩子会被执行。 确定首层依赖模块，就是dependencies 和 devDependencies 属性中直接指定的模块 或者 后面的参数 工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。 获取模块，npm 向 registry 查询模块压缩包的网址 模块扁平化。上面提到的一棵完整的依赖树，其中可能包含大量重复模块，比如A依赖的模块B也依赖了，在npm3之前会严格按照依赖树的结构进行安装，因为会造成冗余，但是3开始默认加入了dedupe的过程，会遍历所有节点，逐个将模块放到根节点下，如果重复会丢弃 安装模块，更新工程中的 node_modules，并执行模块中的生命周期函数 总结 npm install 命令。默认会找到当前路径下的package.json。然后安装其中的依赖 常用命令–forceinstall前会检查目录中是否已经存在指定模块，如果存在就不再安装，因此可以使用-f或--force参数，无论有无按照，都强制重新安装： npm install &lt;packageName&gt; --force –cache-min所有模块都从缓存安装，这样就大大加快了下载速度 npm install --cache-min Infinity &lt;package-name&gt; –save 或者–save-dev在当前目录生成一个package.json文件，记录项目信息（作者，命令设置，项目名称和版本号等）方便后续的项目添加和其他开发者使用。 把模块信息保存到dependencies(生成环境依赖)中： npm install packagename --save 或 -S 把模块信息保存到devDependencies(开发环境依赖)中： npm install packagename --save-dev 或 -D 安装全局的模块（不加参数的时候默认安装本地模块）： npm install packagename -g 或 --global]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端监控平台实践思考]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[错误拦截和上报具体可看本blog另外一篇文章《谈前端异常捕获》 采取单请求上报的方式，上报记录都存在Localstorage，每次将当前记录到监控信息列表一起上报，成功后再继续上报。 场景还原]]></content>
  </entry>
  <entry>
    <title><![CDATA[判断两个object是否相等]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AAobject%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[背景在js中，判断两个自变量对象是否一直（键-值，逐一对应），不能直接使用“==”或者”===”判断是否相等。自变量对象都是指向不同地址的。会返回false ，例如：123var obj1 = &#123;&apos;a&apos;:1&#125;;var obj2 = &#123;&apos;a&apos;:1&#125;;console.log(obj1 === obj2); //false 也不能将对象转换为string后判断1JSON.stringify(obj1)==JSON.stringify(obj2) 因为js的obect的存储具有无序性，即属性数序可能不一致，这种方式不准确。 思考检查对象的“值相等”我们是需要遍历的对象的每个属性，逐一看看它们是否相等。其中需要考虑： 1) 如果该属性值之一本身是对象，需要 递归调用函数2)选择递归这种模式，需要考虑到函数被改名要同时修改函数里面的函数名，即isObjectValueEqual被改名后，函数里面的isObjectValueEqual也需要修改为一致的函数名？3) 如果属性值中的一个是NaN（在JavaScript中，等于它自身）4) 如果一个属性的值为undefined，而另一个对象没有这个属性 注意1）callee 是 arguments 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。但是！在严格模式下，第5版 ECMAScript (ES5) 禁止使用 arguments.callee()因此，即便考虑到上面场景2，但是处于规范，弃用callee2）使用_typeof函数来判断值类型和have来判断数组中是否含有某个元素。他们都来自我自己写的一个简单js函数库 f.js 。具体源码 [https://xiannv.github.io/js/f.js][1]这里不详细展开类型判断和数组问题 function isObjectValueEqual(a, b) { /* * @Author: floralin * @Date: 2017-08-09 11:14:15 * @Last Modified by: floralin * @Last Modified time: 2017-08-09 20:58:00 * @Desc: 递归判断两个对象是否相等 */ for (var aProps in a) { var propName = aProps; // If values of same property are not equal, // objects are not equivalent if (_typeof(a[propName]) != _typeof(b[propName])) { return false } else if ( [&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;, &quot;undefined&quot;, &quot;null&quot;].have(_typeof(a[propName])) &amp;&amp; [&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;, &quot;undefined&quot;, &quot;null&quot;].have(_typeof(b[propName]))) { if (a[propName] !== b[propName]) { return false; } } else if (_typeof(a[propName]) == &quot;function&quot;) { if (a[propName].toString() != b[propName].toString()) { return false; }; } else { return isObjectValueEqual(a[propName], b[propName]) } } return true; } var obj1 = { name: &quot;xiannv&quot;, sex: &quot;female&quot;, jump: function() { }, children: [{ name: &quot;flora&quot;, age: 12 }], }; var obj2 = { name: &quot;xiannv&quot;, sex: &quot;female&quot;, jump: function() { }, children: [{ name: &quot;flora&quot;, age: 12 }], }; console.log(isObjectValueEqual(obj1, obj2)); 使用场景场景1，用户插入新数据。用户需要插入一条新纪录，用于对比现有的所有数据，避免用户重复插入相同数据。场景2，发http请求。对比上一次请求的参数和这次是否相同，相同就不发出新请求。这个在需要提供多重筛选条件的数据展示或操作型应用，很常见用。场景3，还有各种需要肉眼逐一对比两个错误日志等等是否完全相等的看瞎眼案例，手动复制到控制台，直接运行。当然，上面的两个问题，还有其他不同的技术方案来解决。改造一下上面的代码，可以用来判断，对象b是否含有对象a的全部属性或者对象b的数据格式和对象a有什么差异等等，等等]]></content>
  </entry>
  <entry>
    <title><![CDATA[谈前端异常捕获]]></title>
    <url>%2F2019%2F02%2F13%2F%E8%B0%88%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[异常捕获方法try catchtry catch判断代码时候存在错误。优点：可以很好的捕获异常并进行响应处理，不让页面报错挂掉。缺点：需要在捕获异常的代码上进行包裹，会导致页面臃肿不堪，不适用于整个项目的异常捕获。 window.onerror参数：errorMessage-异常信息, scriptURI-异常文件路径, lineNo-异常行号, columnNo-异常列号, error-异常堆栈信息 优点：提供全局监听异常的功能。缺点：跨域之后，无法捕获异常信息，统一返回script error。 使用windowerror异常捕获问题针对上述所提到的跨域之后，无法捕获异常信息。解决方案：script属性配置 crossorigin=&quot;anonymous&quot; 并且服务器添加Access-Control-Allow-Origin 压缩后脚本定位一般上线之前会对代码进行压缩，一方面节省源码体积，另外一方面合并多个文件，减少http请求数。这时候会出现压缩后无法找到原始报错位置的问题。解决方案：利用webpack打包压缩后生成一份对应脚本的map文件就能进行追踪了，在webpack中开启source-map功能。 12345module.exports = &#123; \\... devtool: &apos;#source-map&apos;, \\... &#125; 《Source Map详解》 错误被框架自身捕获项目使用MVVM框架，window.onerror捕获不到异常，因为被框架自身的异常机制捕获了。比如Vue 2.x中使用Vue.config.errorHandler捕获全局异常]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2019%2F02%2F13%2FVue%2F</url>
    <content type="text"><![CDATA[Vue的目标是实现 响应的数据绑定 和 组合的视图组件，所以其核心有两块： 数据绑定系统 组件系统 数据通过在HTML模板中的指令和 “Mustache” 语法，绑定到对应的HTML元素上，其底层是JavaScript对象的存取器属性 和 原生javascript事件。组件系统则通过扩展的Vue实例，来渲染位于HTML中的类似于自定义元素的Vue组件，从而实现独立可复用的组件。 组件化组件分类 通用组件，大部分UI库都是这种组件，比如表单布局弹窗等 业务组件，和需求挂钩，会被复用，比如抽奖摇一摇等 页面组件，每个页面都是一个组件，不会被复用 第三方组件1npm install iview --save More info: IView 组件注册HTML中名称是不区分大小写的，所以浏览器所有大写字符解析成小写字符，这意味着当你使用dom中模版时，AutoStaffList 需要用等价的auto-staff-list形式 12//全局注册Vue.component(&apos;AutoStaffList&apos;,&#123;&#125;) 使用 123&lt;div&gt;&lt;auto-staff-list&gt;&lt;/auto-staff-list&gt;&lt;/div&gt; 局部注册 123456new Vue(&#123; el:&apos;#app&apos;, components:&#123; &apos;AutoStaffList&apos;:AutoStaffList &#125;&#125;) Props使用v-bind:xx给子组件传递数据，组件内部使用props字段接收，使用和挂载在this上的数据没有本质区别，但是需要注意props的数据子组件不能直接修改，这是为了单向数据流的设计，props只能通知父组件进行修改 使用provide&amp;inject内部共享数据业务中不常用的api，主要用于高阶组件和组件库使用，用来和所有子孙元素提供数据，类似react的上下文。 思考：Form的核心是做数据校验，一个Form里包含多个FormItem，当点击按钮的时候，需要逐一对每个输入框进行校验，所以每个FormItem都需要有一个验证方法，汇总到Form返回 KForm负责定义校验规则 KFormItem负责显示错误数据 KInput负责数据双向绑定 常见问题v-if和v-show的区别编译区别： v-if是惰性的，如果初始条件为假则这个元素不会被编译，只有当条件第一次为真时，Vue才编译并缓存编译结果以供后续使用；v-show的元素则直接编译。 显示区别： v-if是真实的在HTML中重建或者销毁这个元素，v-show则只是通过display来控制，简单得多。 结论： v-if有更高的切换消耗而v-show有更高的初始渲染消耗，频繁切换用v-show，条件稳定用v-if Theme-next Document]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartDownload and Install1sudo npm install -g hexo-cli Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Your styleTheme-next Document]]></content>
  </entry>
</search>
